Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 168�175,
Prague, Czech Republic, June 2007. c 2007 Association for Computational Linguistics
Transforming Projective Bilexical Dependency Grammars into
efficiently-parsable CFGs with Unfold-Fold
Mark Johnson
Microsoft Research Brown University
Redmond, WA Providence, RI
t-majoh@microsoft.com Mark Johnson@Brown.edu
Abstract
This paper shows how to use the UnfoldFold transformation to transform Projective
Bilexical Dependency Grammars (PBDGs)
into ambiguity-preserving weakly equivalent Context-Free Grammars (CFGs). These
CFGs can be parsed in O(n3) time using a
CKY algorithm with appropriate indexing,
rather than the O(n5) time required by a
naive encoding. Informally, using the CKY
algorithm with such a CFG mimics the steps
of the Eisner-Satta O(n3) PBDG parsing algorithm. This transformation makes all of
the techniques developed for CFGs available
to PBDGs. We demonstrate this by describing a maximum posterior parse decoder for
PBDGs.
1 Introduction
Projective Bilexical Dependency Grammars (PBDGs) have attracted attention recently for two reasons. First, because they capture bilexical head-tohead dependencies they are capable of producing
extremely high-quality parses: state-of-the-art discriminatively trained PBDG parsers rival the accuracy of the very best statistical parsers available today (McDonald, 2006). Second, Eisner-Satta O(n3)
PBDG parsing algorithms are extremely fast (Eisner,
1996; Eisner and Satta, 1999; Eisner, 2000).
This paper investigates the relationship between
Context-Free Grammar (CFG) parsing and the Eisner/Satta PBDG parsing algorithms, including their
extension to second-order PBDG parsing (McDonald, 2006; McDonald and Pereira, 2006). Specifically, we show how to use an off-line preprocessing
step, the Unfold-Fold transformation, to transform a
PBDG into an equivalent CFG that can be parsed in
O(n3) time using a version of the CKY algorithm
with suitable indexing (Younger, 1967), and extend
this transformation so that it captures second-order
PBDG dependencies as well. The transformations
are ambiguity-preserving, i.e., there is a one-toone mapping between dependency parses and CFG
parses, so it is possible to map the CFG parses back
to the PBDG parses they correspond to.
The PBDG to CFG reductions make techniques
developed for CFGs available to PBDGs as well. For
example, incremental CFG parsing algorithms can
be used with the CFGs produced by this transform,
as can the Inside-Outside estimation algorithm (Lari
and Young, 1990) and more exotic methods such as
estimating adjoined hidden states (Matsuzaki et al.,
2005; Petrov et al., 2006). As an example application, we describe a maximum posterior parse decoder for PBDGs in Section 8.
The Unfold-Fold transformation is a calculus for
transforming functional and logic programs into
equivalent but (hopefully) faster programs (Burstall
and Darlington, 1977). We use it here to transform CFGs encoding dependency grammars into
other CFGs that are more efficiently parsable. Since
CFGs can be expressed as Horn-clause logic programs (Pereira and Shieber, 1987) and the UnfoldFold transformation is provably correct for such programs (Sato, 1992; Pettorossi and Proeitti, 1992), it
follows that its application to CFGs is provably correct as well. The Unfold-Fold transformation is used
here to derive the CFG schemata presented in sections 5�7. A system that uses these schemata (such
as the one described in section 8) can implement
168
these schemata directly, so the Unfold-Fold transformation plays a theoretical role in this work, justifying the resulting CFG schemata.
The closest related work we are aware of
is McAllester (1999), which also describes a reduction of PBDGs to efficiently-parsable CFGs
and directly inspired this work. However, the
CFGs produced by McAllester's transformation include epsilon-productions so they require a specialized CFG parsing algorithm, while the CFGs produced by the transformations described here have
binary productions so they can be parsed with
standard CFG parsing algorithms. Further, our
approach extends to second-order PBDG parsing,
while McAllester only discusses first-order PBDGs.
The rest of this paper is structured as follows.
Section 2 defines projective dependency graphs and
grammars and Section 3 reviews the "naive" encoding of PBDGs as CFGs with an O(n5) parse time,
where n is the length of the string to be parsed. Section 4 introduces the "split-head" CFG encoding of
PBDGs, which has an O(n4) parse time and serves
as the input to the Unfold-Fold transform. Section 5
uses the Unfold-Fold transform to obtain a weaklyequivalent CFG encoding of PBDGs which can be
parsed in O(n3) time, and presents timing results
showing that the transformation does speed parsing.
Sections 6 and 7 apply Unfold-Fold in slightly more
complex ways to obtain CFG encodings of PBDGs
that also make second-order dependencies available
in O(n3) time parsable CFGs. Section 8 applies a
PBDG to CFG transform to obtain a maximum posterior decoding parser for PBDGs.
2 Projective bilexical dependency parses
and grammars
Let  be a finite set of terminals (e.g., words),
and let 0 be the root terminal not in . If w =
(w1, . . . , wn)  , let w = (0, w1, . . . , wn), i.e.,
w is obtained by prefixing w with 0. A dependency
parse G for w is a tree whose root is labeled 0 and
whose other n vertices are labeled with each of the n
terminals in w. If G contains an arc from u to v then
we say that v is a dependent of u, and if G contains
a path from u to v then we say that v is a descendant
of u. If v is dependent of u that also precedes u in
w then we say that v is a left dependent of u (right
dependent and left and right descendants are defined
similarly).
0 Sandy gave the dog a bone
Figure 1: A projective dependency parse for the sentence "Sam gave the dog a bone".
A dependency parse G is projective iff whenever
there is a path from u to v then there is also a path
from u to every word between u and v in w as well.
Figure 1 depicts a projective dependency parse for
the sentence "Sam gave the dog a bone".
A projective dependency grammar defines a set of
projective dependency parses. A Projective Bilexical Dependency Grammar (PBDG) consists of two
relations and , both defined over (  {0}) �
. A PBDG generates a projective dependency
parse G iff u v for all right dependencies (u, v)
in G and v u for all left dependencies (u, v) in
G. The language generated by a PBDG is the set
of strings that have projective dependency parses
generated by the grammar. The following dependency grammar generates the dependency parse in
Figure 1.
0 gave Sandy gave
gave dog the dog
gave bone a bone
This paper does not consider stochastic dependency grammars directly, but see Section 8 for an
application involving them. However, it is straightforward to associate weights with dependencies, and
since the dependencies are preserved by the transformations, obtain a weighted CFG. Standard methods
for converting weighted CFGs to equivalent PCFGs
can be used if required (Chi, 1999). Alternatively,
one can transform a corpus of dependency parses
into a corpus of the corresponding CFG parses, and
estimate CFG production probabilities directly from
that corpus.
3 A naive encoding of PBDGs
There is a well-known method for encoding a PBDG
as a CFG in which each terminal u   is associated
with a corresponding nonterminal Xu
that expands
to u and all of u's descendants. The nonterminals of
the naive encoding CFG consist of the start symbol
S and symbols Xu
for each terminal u  , and
169
the productions of the CFG are the instances of the
following schemata:
S  Xu
where 0 u
Xu
 u
Xu
 Xv
Xu
where v u
Xu
 Xu
Xv
where u v
The dependency annotations associated with each
production specify how to interpret a local tree generated by that production, and permit us to map a
CFG parse to the corresponding dependency parse.
For example, the top-most local tree in Figure 2 was
generated by the production S  Xgave
, and indicate that in this parse 0 gave.
Given a terminal vocabulary of size m the CFG
contains O(m2) productions, so it is impractical to
enumerate all possible productions for even modest
vocabularies. Instead productions relevant to a particular sentence are generated on the fly.
The naive encoding CFG in general requires
O(n5) parsing time with a conventional CKY parsing algorithm, since tracking the head annotations u
and v multiplies the standard O(n3) CFG parse time
requirements by an additional factor proportional to
the O(n2) productions expanding Xu
.
An additional problem with the naive encoding
is that the resulting CFG in general exhibits spurious ambiguities, i.e., a single dependency parse may
correspond to more than one CFG parse, as shown
in Figure 2. Informally, this is because the CFG permits left and the right dependencies to be arbitrarily
intermingled.
4 Split-head encoding of PBDGs
There are several ways of removing the spurious ambiguities in the naive CFG encoding just described.
This section presents a method we call the "splithead encoding", which removes the ambiguities and
serves as starting point for the grammar transforms
described below.
The split-head encoding represents each word u
in the input string w by two unique terminals ul
and ur in the CFG parse. A split-head CFG's terminal vocabulary is  = {ul, ur : u  },
where  is the set of terminals of the PBDG. A
PBDG parse with yield w = (u1, . . . , un) is transformed to a split-head CFG parse with yield w =
(u1,l, u1,r, . . . , un,l, un,r), so |w| = 2|w|.
S
the dog
Xthe
Xdog
Xdog
Xgave
gave
Xgave
Xbone
Xa
a
Xbone
bone
Xgave
XSandy
Sandy
Xgave
S
the dog
Xthe
Xdog
Xdog
Xbone
Xa
a
Xbone
bone
Xgave
Xgave
gave
XSandy
Sandy
Xgave
Xgave
Figure 2: Two parses using the naive CFG encoding that both correspond to the dependency parse of
Figure 1.
The split-head CFG for a PBDG is given by the
following schemata:
S  Xu
where 0 u
Xu
 Lu u
R where u  
Lu
 ul
Lu
 Xv
Lu
where v u
u
R  ur
u
R  u
R Xv
where u v
The dependency parse shown in Figure 1 corresponds to the split-head CFG parse shown in Figure 3. Each Xu
expands to two new categories, Lu
and u
R. Lu
consists of ul and all of u's left descendants, while u
R consists of ur and all of u's right
descendants. The spurious ambiguity present in the
naive encoding does not arise in the split-head encoding because the left and right dependents of a
head are assembled independently and cannot intermingle.
As can be seen by examining the split-head
schemata, the rightmost descendant of Lu
is either
Lu
or ul, which guarantees that the rightmost terminal dominated by Lu
is always ul; similarly the leftmost terminal dominated by u
R is always ur. Thus
170
dog
R
XSandy
LSandy
Sandyl
Xdog
gaver
gavel
gave
R
gave
R
La
al
a
R
ar
Xa
Lbone
bonel
Lbone
boner
bone
R
Xbone
Sandy
R
Sandyr
Lgave
Lgave
Xgave
S
gave
R
Lthe
thel
the
R
ther
Xthe
Ldog
dogl
Ldog
dogr
Figure 3: The split-head parse corresponding to the dependency graph depicted in Figure 1. Notice that ul
is always the rightmost descendant of Lu
and ur is always the leftmost descendant of u
R, which means that
these indices are redundant given the constituent spans.
these subscript indices are redundant given the string
positions of the constituents, which means we do not
need to track the index u in Lu
and u
R but can parse
with just the two categories L and R, and determine
the index from the constituent's span when required.
It is straight-forward to extend the split-head CFG
to encode the additional state information required
by the head automata of Eisner and Satta (1999);
this corresponds to splitting the non-terminals Lu
and u
R. For simplicity we work with PBDGs in this
paper, but all of the Unfold-Fold transformations described below extend to split-head grammars with
the additional state structure required by head automata.
Implementation note: it is possible to directly
parse the "undoubled" input string w by modifying
both the CKY algorithm and the CFGs described
in this paper. Modify Lu
and u
R so they both ultimately expand to the same terminal u, and specialcase the implementation of production Xu
 Lu u
R
and all productions derived from it to permit Lu
and
u
R to overlap by the terminal u.
The split-head formulation explains what initially
seem unusual properties of existing PBDG algorithms. For example, one of the standard "sanity
checks" for the Inside-Outside algorithm--that the
outside probability of each terminal is equal to the
sentence's inside probability--fails for these algorithms. In fact, the outside probability of each terminal is double the sentence's inside probability because these algorithms implicitly collapse the two
terminals ul and ur into a single terminal u.
5 A O(n3
) split-head grammar
The split-head encoding described in the previous
section requires O(n4) parsing time because the index v on Xv
is not redundant. We can obtain an
equivalent grammar that only requires O(n3) parsing time by transforming the split-head grammar using Unfold-Fold. We describe the transformation on
Lu
; the transformation of u
R is symmetric.
We begin with the definition of Lu
in the splithead grammar above ("|" separates the right-hand
sides of productions).
Lu
 ul | Xv
Lu
where v u
Our first transformation step is to unfold Xv
in Lu
,
i.e., replace Xv
by its expansion, producing the following definition for Lu
(ignore the underlining for
now).
Lu
 ul | Lv v
R Lu
where v u
This removes the offending Xv
in Lu
, but the resulting definition of Lu
contains ternary productions and
so still incurs O(n4) parse time. To address this we
define new nonterminals x
My
for each x, y  :
x
My
 x
R Ly
and fold the underlined children in Lu
into v
Mu
:
x
My
 x
R Ly
where x, y  
Lu
 ul | Lv v
Mu
where v u
171
S
dogr
ther
Ldog
the
R
the
Mdog
thel
Lthe
Ldog
dogl
gaver
gave
R
gave
Mdog
gavel
dog
R
gave
R
al
ar
a
R
bonel
Lbone
a
Mbone
La
Lbone
gave
Mbone bone
R
boner
gave
R
Lgave
Lgave
Sandy
R
Sandy
Mgave
LSandy
Sandyl
Sandyr
Figure 4: The O(n3) split-head parse corresponding to the dependency graph of Figure 1.
The O(n3) split-head grammar is obtained by unfolding the occurence of Xu
in the S production and
dropping the Xu
schema as Xu
no longer appears on
the right-hand side of any production. The resulting
O(n3) split-head grammar schemata are as follows:
S  Lu u
R where 0 u
Lu
 ul
Lu
 Lv v
Mu
where v u
u
R  ur
u
R  u
Mv v
R where u v
x
My
 x
R Ly
where x, y  
As before, the dependency annotations on the production schemata permit us to map CFG parses to
the corresponding dependency parse. This grammar
requires O(n3) parsing time to parse because the indices are redundant given the constituent's string positions for the reasons described in section 4. Specifically, the rightmost terminal of Lu
is always ul, the
leftmost terminal of u
R is always ur and the leftmost and rightmost terminals of v
Mu
are vl and ur
respectively.
The O(n3) split-head grammar is closely related
to the O(n3) PBDG parsing algorithm given by Eisner and Satta (1999). Specifically, the steps involved
in parsing with this grammar using the CKY algorithm are essentially the same as those performed
by the Eisner/Satta algorithm. The primary difference is that the Eisner/Satta algorithm involves two
separate categories that are collapsed into the single
category M here.
To confirm their relative performance we implemented stochastic CKY parsers for the three CFG
schemata described so far. The production schemata
were hard-coded for speed, and the implementation
trick described in section 4 was used to avoid doubling the terminal string. We obtained dependency
weights from our existing discriminatively-trained
PBDG parser (not cited to preserve anonymity). We
compared the parsers' running times on section 24
of the Penn Treebank. Because all three CFGs implement the same dependency grammar their Viterbi
parses have the same dependency accuracy, namely
0.8918. We precompute the dependency weights,
so the times include just the dynamic programming
computation on a 3.6GHz Pentium 4.
CFG schemata sentences parsed / second
Naive O(n5) CFG 45.4
O(n4) CFG 406.2
O(n3) CFG 3580.0
6 An O(n3
) adjacent-head grammar
This section shows how to further transform the
O(n3) grammar described above into a form that
encodes second-order dependencies between adjacent dependent heads in much the way that a
Markov PCFG does (McDonald, 2006; McDonald
and Pereira, 2006). We provide a derivation for the
Lu
constituents; there is a parallel derivation for u
R.
We begin by unfolding Xv
in the definition of Lu
in the split-head grammar, producing as before:
Lu
 ul | Lv v
R Lu
Now introduce a new nonterminal v
M
L
u
, which is a
specialized version of M requiring that v is a leftdependent of u, and fold the underlined constituents
172
S
ther
the
R
the
M
L
dog
thel
Lthe
Ldog dog
R
dogl
dogr
Lbone
La a
M
L
bone
a
R
ar
al
bonel
boner
gaver
gave
M
R
dog dog
Mbone
gave
M
R
bone bone
R
gave
R
gavel
Sandyr
Sandy
R
Sandyl
Sandy
M
L
gave
LSandy
Lgave
Figure 5: The O(n3) adjacent-head parse corresponding to the dependency graph of Figure 1. The boxed
local tree indicates bone is the dependent of give following the dependent dog, i.e., give dog bone .
into v
M
L
u
.
v
M
L
u
 v
R Lu
where v u
Lu
 ul | Lv v
M
L
u
where v u
Now unfold Lu
in the definition of v
M
L
u
, producing:
v
M
L
u
 v
R ul | v
R Lv v M
L
u
; v v u
Note that in the first production expanding v
M
L
u
, v
is the closest left dependent of u, and in the second
production v and v are adjacent left-dependents of
u. v
M
L
u
has a ternary production, so we introduce
x
My
as before to fold the underlined constituents
into.
x
My
 x
R Ly
where x, y  
v
M
L
u
 v
R ul | v
Mv v M
L
u
; v v u
The resulting grammar schema is as below, and a
sample parse is given in Figure 5.
S  Lu u
R where 0 u
Lu
 ul u has no left dependents
Lu
 Lv v
M
L
u
v is u's last left dep.
v
M
L
u
 v
R ul v is u's closest left dep.
v
M
L
u
 v
Mv v M
L
u
v v u
u
R  ur u has no right dependents
u
R  u
M
R
v v
R v is u's last right dep.
u
M
R
v
 ur Lv
v is u's closest right dep.
u
M
R
v
 u
M
R
v v Mv
u v v
x
My
 x
R Ly
where x, y  
As before, the indices on the nonterminals are redundant, as the heads are always located at an edge
of each constituent, so they need not be computed
or stored and the CFG can be parsed in O(n3) time.
The steps involved in CKY parsing with this grammar correspond closely to those of the McDonald
(2006) second-order PBDG parsing algorithm.
7 An O(n3
) dependent-head grammar
This section shows a different application of UnfoldFold can capture head-to-head-to-head dependencies, i.e., "vertical" second-order dependencies,
rather than the "horizontal" ones captured by the
transformation described in the previous section.
Because we expect these vertical dependencies to
be less important linguistically than the horizontal
ones, we only sketch the transformation here.
The derivation differs from the one in Section 6 in
that the dependent v
R, rather than the head Lu
, is unfolded in the initial definition of v
M
L
u
. This results in
a grammar that tracks vertical, rather than horizontal, second-order dependencies. Since left-hand and
right-hand derivations are assembled separately in a
split-head grammar, the grammar in fact only tracks
zig-zag type dependencies (e.g., where a grandparent has a right dependent, which in turn has a left
dependent).
The resulting grammar is given below, and a sample parse using this grammar is shown in Figure 6.
Because the subscripts are redundant they can be
omitted and the resulting CFG can be parsed in
173
gave
M
R
bone
gaver
gave
R Lthe
thel
gave
Mthe
ther
dogl
Ldog
the
M
L
dog
dogr
dog
R
gave
R La
al
ar
gave
Ma a
M
L
bone
Lbone
bonel
boner
bone
R
gave
R
Lgave
gavel
Sandyr
Sandy
M
L
gave
Sandyl
LSandy
gave
M
R
dog
S
Lgave
Figure 6: The n3 dependent-head parse corresponding to the dependency graph of Figure 1. The boxed
local tree indicates that a is a left-dependent of bone, which is in turn a right-dependent of gave, i.e.,
gave a bone .
O(n3) time using the CKY algorithm.
S  Lu u
R where 0 u
Lu
 ul
Lu
 Lv v
M
L
u
where v u
v
M
L
u
 vr Lu
where v u
v
M
L
u
 v
M
R
w w
Mu
where v w u
u
R  ur
u
R  u
M
R
v v
R where u v
u
M
R
v
 u
R vl where u v
u
M
R
v
 u
Mw w
M
L
v
where u w u
x
My
 x
R Ly
where x, y  
8 Maximum posterior decoding
As noted in the introduction, one consequence of the
PBDG to CFG reductions presented in this paper is
that CFG parsing and estimation techniques are now
available for PBDGs as well. As an example application, this section describes Maximum Posterior
Decoding (MPD) for PBDGs.
Goodman (1996) observed that the Viterbi parse
is in general not the optimal parse for evaluation
metrics such as f-score that are based on the number
of correct constituents in a parse. He showed that
MPD improves f-score modestly relative to Viterbi
decoding for PCFGs.
Since dependency parse accuracy is just the proportion of dependencies in the parse that are correct,
Goodman's observation should hold for PBDG parsing as well. MPD for PBDGs selects the parse that
maximizes the sum of the marginal probabilities of
each of the dependencies in the parse. Such a decoder might plausibly produce parses that score better on the dependency accuracy metric than Viterbi
parses.
MPD is straightforward given the PBDG to CFG
reductions described in this paper. Specifically, we
use the Inside-Outside algorithm to compute the
posterior probability of the CFG constituents corresponding to each PBDG dependency, and then use
the Viterbi algorithm to find the parse tree that maximizes the sum of these posterior probabilities.
We implemented MPD for first-order PBDGs
using dependency weights from our existing
discriminatively-trained PBDG parser (not cited to
preserve anonymity). These weights are estimated
by an online procedure as in McDonald (2006), and
are not intended to define a probability distribution.
In an attempt to heuristically correct for this, in this
experiment we used exp(wu,v) as the weight of the
dependency between head u and dependent v, where
wu,v is the weight provided by the discriminativelytrained model and  is an adjustable scaling parameter tuned to optimize MPD accuracy on development
data.
Unfortunately we found no significant difference between the accuracy of the MPD and Viterbi
parses. Optimizing MPD on the development data
(section 24 of the PTB) set the scale factor  =
0.21 and produced MPD parses with an accuracy
of 0.8921, which is approximately the same as the
Viterbi accuracy of 0.8918. On the blind test data
(section 23) the two accuracies are essentially iden174
tical (0.8997).
There are several possible explanations for the
failure of MPD to produce more accurate parses than
Viterbi decoding. Perhaps MPD requires weights
that define a probability distribution (e.g., a MaxEnt model). It is also possible that discriminative
training adjusts the weights in a way that ensures
that the Viterbi parse is close to the maximum posterior parse. This was the case in our experiment,
and if this is true with discriminative training in general, then maximum posterior decoding will not have
much to offer to discriminative parsing.
9 Conclusion
This paper shows how to use the Unfold-Fold transform to translate PBDGs into CFGs that can be
parsed in O(n3) time. A key component of this is
the split-head construction, where each word u in the
input is split into two terminals ul and ur of the CFG
parse. We also showed how to systematically transform the split-head CFG into grammars which track
second-order dependencies. We provided one grammar which captures horizontal second-order dependencies (McDonald, 2006), and another which captures vertical second-order head-to-head-to-head dependencies.
The grammars described here just scratch the surface of what is possible with Unfold-Fold. Notice
that both of the second-order grammars have more
nonterminals than the first-order grammar. If one is
prepared to increase the number of nonterminals still
further, it may be possible to track additional information about constituents (although if we insist on
O(n3) parse time we will be unable to track the interaction of more than three heads at once).
References
R.M. Burstall and John Darlington. 1977. A transformation
system for developing recursive programs. Journal of the
Association for Computing Machinery, 24(1):44�67.
Zhiyi Chi. 1999. Statistical properties of probabilistic contextfree grammars. Computational Linguistics, 25(1):131�160.
Jason Eisner and Giorgio Satta. 1999. Efficient parsing for
bilexical context-free grammars and head automaton grammars. In Proceedings of the 37th Annual Meeting of the
Association for Computational Linguistics, pages 457�480,
University of Maryland.
Jason Eisner. 1996. Three new probabilistic models for dependency parsing: An exploration. In COLING96: Proceedings
of the 16th International Conference on Computational Linguistics, pages 340�345, Copenhagen. Center for Sprogteknologi.
Jason Eisner. 2000. Bilexical grammars and their cubic-time
parsing algorithms. In Harry Bunt and Anton Nijholt, editors, Advances in Probabilistic and Other Parsing Technologies, pages 29�62. Kluwer Academic Publishers.
Joshua T. Goodman. 1996. Parsing algorithms and metrics. In
Proceedings of the 34th Annual Meeting of the Association
for Computational Linguistics, pages 177�183, Santa Cruz,
Ca.
K. Lari and S.J. Young. 1990. The estimation of Stochastic
Context-Free Grammars using the Inside-Outside algorithm.
Computer Speech and Language, 4(35-56).
Takuya Matsuzaki, Yusuke Miyao, and Jun'ichi Tsujii. 2005.
Probabilistic CFG with latent annotations. In Proceedings
of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL'05), pages 75�82, Ann Arbor,
Michigan, June. Association for Computational Linguistics.
David McAllester. 1999. A reformulation of Eisner and Sata's
cubic time parser for split head automata grammars. Available from http://ttic.uchicago.edu/~dmcallester/.
Ryan McDonald and Fernando Pereira. 2006. Online learning of approximate dependency parsing algorithms. In 11th
Conference of the European Chapter of the Association for
Computational Linguistics, pages 81�88, Trento, Italy.
Ryan McDonald. 2006. Discriminative Training and Spanning
Tree Algorithms for Dependency Parsing. Ph.D. thesis, University of Pennyslvania, Philadelphia, PA.
Fernando Pereira and Stuart M. Shieber. 1987. Prolog and Natural Language Analysis. Center for the Study of Language
and Information, Stanford, CA.
Slav Petrov, Leon Barrett, Romain Thibaux, and Dan Klein.
2006. Learning accurate, compact, and interpretable tree annotation. In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics, pages
433�440, Sydney, Australia, July. Association for Computational Linguistics.
A. Pettorossi and M. Proeitti. 1992. Transformation of logic
programs. In Handbook of Logic in Artificial Intelligence,
volume 5, pages 697�787. Oxford University Press.
Taisuke Sato. 1992. Equivalence-preserving first-order unfold/fold transformation systems. Theoretical Computer Science, 105(1):57�84.
Daniel H. Younger. 1967. Recognition and parsing of
context-free languages in time n3
. Information and Control,
10(2):189�208.
175

